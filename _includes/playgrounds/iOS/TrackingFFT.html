<p><h3>Tracking Amplitude
</h3><h4>Tracking the amplitude of one node&#39;s output using the AKAmplitudeTracker node.
</h4></p>

{% highlight ruby %}
{% endhighlight %}
<p>Standard imports and AudioKit setup:</p>

{% highlight ruby %}import XCPlayground
import AudioKit

let audiokit = AKManager.sharedInstance

let bundle = NSBundle.mainBundle()
let file = bundle.pathForResource("leadloop", ofType: "wav")

var player = AKAudioPlayer(file!)
player.looping = true

{% endhighlight %}
<p>The amplitude tracker&#39;s passes its input to the output, so we can insert into the signal chain at the bottom</p>

{% highlight ruby %}audiokit.audioOutput = player
audiokit.start()
player.play()
let fft = AKFFT(player)

{% endhighlight %}
<p>And here&#39;s where we monitor the results of tracking the amplitude.</p>

{% highlight ruby %}AKPlaygroundLoop(every: 0.1) {
    let max = fft.fftData.maxElement()!
    let index = fft.fftData.indexOf(max)
}

{% endhighlight %}
<p>This keeps the playground running so that audio can play for a long time</p>

{% highlight ruby %}XCPlaygroundPage.currentPage.needsIndefiniteExecution = true

{% endhighlight %}
<p>You can experiment with this playground by changing the volume function to a phasor or another well-known function to see how well the amplitude tracker can track.  Also, you could change the sound source from an oscillator to a noise generator, or any constant sound source (some things like a physical model would not work because the output has an envelope to its volume).  Instead of just plotting our results, we could use the value to drive other sounds or update an app&#39;s user interface.</p>

{% highlight ruby %}
{% endhighlight %}
